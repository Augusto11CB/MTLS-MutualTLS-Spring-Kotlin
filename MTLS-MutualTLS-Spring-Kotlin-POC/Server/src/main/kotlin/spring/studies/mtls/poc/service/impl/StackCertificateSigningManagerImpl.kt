package spring.studies.mtls.poc.service.impl


import org.bouncycastle.asn1.ASN1ObjectIdentifier
import org.bouncycastle.asn1.pkcs.CertificationRequest
import org.bouncycastle.asn1.x500.X500Name
import org.bouncycastle.asn1.x509.AuthorityKeyIdentifier
import org.bouncycastle.asn1.x509.BasicConstraints
import org.bouncycastle.asn1.x509.SubjectKeyIdentifier
import org.bouncycastle.asn1.x509.X509Name
import org.bouncycastle.cert.X509v3CertificateBuilder
import org.bouncycastle.crypto.util.PrivateKeyFactory
import org.bouncycastle.openssl.PEMParser
import org.bouncycastle.operator.ContentSigner
import org.bouncycastle.operator.DefaultDigestAlgorithmIdentifierFinder
import org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder
import org.bouncycastle.operator.bc.BcRSAContentSignerBuilder
import org.bouncycastle.pkcs.PKCS10CertificationRequest
import org.springframework.beans.factory.annotation.Value
import spring.studies.mtls.poc.service.CertificateSigningManager
import spring.studies.mtls.poc.utils.IOUtil
import java.io.ByteArrayInputStream
import java.io.FileInputStream
import java.io.Reader
import java.math.BigInteger
import java.security.KeyFactory
import java.security.KeyPair
import java.security.KeyStore
import java.security.SecureRandom
import java.security.cert.CertificateFactory
import java.security.cert.X509Certificate
import java.security.cert.X509Extension
import java.util.*


abstract class StackCertificateSigningManagerImpl(
        @Value("\${certificates.base.path}") val pathCertificates: String
) : CertificateSigningManager {

    override fun signCSR(pemcsr: Reader, validity: Int, keystore: KeyStore, alias: String, password: kotlin.CharArray) {
        val keyPair = loadPublicAndPrivateKey()

        val privateCAKey = keyPair.private

        val certificateCA = loadCertificate()

        val pemReaderCSR = PEMParser(pemcsr)

        val clientCSR = PKCS10CertificationRequest(pemReaderCSR.readObject() as CertificationRequest)


        val signatureAlgorithm = DefaultSignatureAlgorithmIdentifierFinder().find("SHA1withRSA")
        val digestAlgorithm = DefaultDigestAlgorithmIdentifierFinder().find(signatureAlgorithm)

        val issuerName = X500Name(certificateCA.subjectX500Principal.name)
        val serial = BigInteger(32, SecureRandom())
        val startDateCertificate = Date()
        val endDateCertificate = Date(System.currentTimeMillis() + validity * 86400000L)


        val certGen = X509v3CertificateBuilder(
                issuerName,
                serial,
                startDateCertificate,
                endDateCertificate,
                clientCSR.subject,
                clientCSR.subjectPublicKeyInfo
        )

       /*
       *
       *  certGen.addExtension(ASN1ObjectIdentifier., false, BasicConstraints(false))
       *  certGen.addExtension(X509Extension.subjectKeyIdentifier, false, SubjectKeyIdentifier(csr.getSubjectPublicKeyInfo()))
       *  certGen.addExtension(X509Extension.authorityKeyIdentifier, false, AuthorityKeyIdentifier(GeneralNames(GeneralName(X509Name(cacert.getSubjectX500Principal().getName()))), cacert.getSerialNumber()))
       *
       * */


        val signer = BcRSAContentSignerBuilder(signatureAlgorithm, digestAlgorithm).build(PrivateKeyFactory.createKey(privateCAKey.getEncoded()));
	    val holder = certGen.build(signer);
	    val certificateEncoded = holder.toASN1Structure().encoded;


    }


    private fun loadPublicAndPrivateKey(): KeyPair {
        // TODO Load KeyPair From S3

        val keyFactory = KeyFactory.getInstance("RSA") // TODO Verify if the certificate generated by CA is RSA
        val privateKey = keyFactory.generatePrivate(IOUtil.generateSpec("bla", false)) // Gerar private Keys (tutorial format .der)
        val publicKey = keyFactory.generatePublic(IOUtil.generateSpec("bla", true)) // Gerar public Keys (tutorial format .der)

        return KeyPair(publicKey, privateKey)

    }

    private fun loadCertificate(): X509Certificate {
        // TODO Load FROM S3
        var fis: FileInputStream? = null
        var byteArrayInputStream: ByteArrayInputStream? = null

        // use FileInputStream to read the file
        fis = FileInputStream(pathCertificates.toString() + "CRootCA.der")

        // read the bytes
        val value = ByteArray(fis!!.available())
        fis.read(value)
        fis.close()
        byteArrayInputStream = ByteArrayInputStream(value)

        // get X509 certificate factory
        val certFactory = CertificateFactory.getInstance("X.509")

        // certificate factory can now create the certificate
        return (certFactory.generateCertificate(byteArrayInputStream) as X509Certificate)
    }


}